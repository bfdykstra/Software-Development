package falstad;


import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Random;

public class MazeBuilderEller extends MazeBuilder {
	
	int[] curRow = new int[this.width]; //the current row that the algorithm is operating on
	Hashtable<Integer, Integer> sets = new Hashtable<Integer, Integer>(); //a hashtable with the cell value as a key, and their "set number" 
													 //as a value.
	Random rand = new Random();
	
	int h; //a counter to keep track of which row we are at
	
	public MazeBuilderEller() {
		
		super();
		System.out.println("MazeBuilderPrim uses Eller's algorithm to generate maze.");
	}

	public MazeBuilderEller(boolean deterministic) {
		super(deterministic);
		System.out.println("MazeBuilderPrim uses Eller's algorithm to generate maze.");
		
	}
	
	
	@Override
	protected void generate() {
		// TODO Auto-generated method stub
		super.generate();
	}

	@Override
	protected void generatePathways() {
		// TODO Auto-generated method stub
		while(h < this.height){
			this.setCurRow(h);
			int[] cur = getCurRow();
			this.generateSets(cur); // puts the unique set values into the hashtable
			randJoin(cur, sets); //randomly join adjacent cells if they are not in the same set
			
			//Randomly determine vertical connections, with at least 1 per set
			
			//need to get each unique set in curRow
			ArrayList<Integer> setIDs = new ArrayList<Integer>();
			for(int i = 0; i < curRow.length; i++){
				int refSetID = sets.get(curRow[i]);
				while(sets.get(curRow[i]) == refSetID){
					i++;
				}
				setIDs.add(refSetID);
			}
			
			//Randomly determine vertical connections, with at least 1 per set
			for(int j = 0; j < setIDs.size(); j++){
				this.verticalConnect(setIDs.get(j));
			}
			
			h++; //increment row up one to get ready for next loop
			
		}
		this.setCurRow(h);
		this.randJoin(curRow, sets); // joins last row up
		
	}

	
	/**
	 * sets and returns the curRow
	 * @param cellRow the row from Cells that is being inspected
	 * @return int[] with values of the row from cells array
	 */
	protected void setCurRow(int cellRow){
		for(int i = 0; i < this.width; i ++){
			curRow[i] = this.cells.getValueOfCell(cellRow, i);
		}
	}
	
	
	protected int[] getCurRow(){
		return curRow;
	}
	
	/**
	 * randomly joins adjacent cells that belong to different sets. The cells that 
	 * are joined are also put into the same set.
	 * @param row
	 * @param sets
	 */
	protected void randJoin(int[] row, Hashtable<Integer, Integer> sets){
		
		int maxNumJoin = row.length; //would happen if all cells in row were part of different sets
		int numSets = this.getNumSets(row);
		
		//joins must be between number of sets and maxNumJoin
		int numJoins = rand.nextInt((maxNumJoin - numSets) + 1) + numSets;
		
		ArrayList<Integer> randNdxs = this.getRandomIndices(numJoins);
		
		//now we get cells from ndxs
		for(int j = 0; j< randNdxs.size(); j++){
			
			//the randomly chosen cell!!
			int refCell = row[randNdxs.get(j)];
			
			//check if the index is going to be at end
			if(randNdxs.get(j) + 1 < this.width){
				int adjCell = row[randNdxs.get(j) + 1]; //cell next to refCell
				
				//we now check if they are part of the same set, if not, we add them to the same set
				if(! (this.areSameSet(refCell, adjCell) )){
					int refCellSet = sets.get(refCell);
					sets.put(adjCell, refCellSet);
					
					//delete wall between refCell and the adjacent cell-- randNdxs.get(j) is the index of the randomly chosen cell
					this.cells.deleteWall(randNdxs.get(j), this.h, 1, 0);
				}
			}
			
			else{
				int adjCell = row[randNdxs.get(j) - 1]; //It was the last ndx, so it gets cell to the left
				
				//we now check if they are part of the same set, if not, we add them to the same set
				if(! (this.areSameSet(refCell, adjCell) )){
					int refCellSet = sets.get(refCell);
					sets.put(adjCell, refCellSet); //adds adjacent cell to the master set with the reference cell's set #
					
					//delete wall between refCell and the adjacent cell -- randNdxs.get(j) is the index of the randomly chosen cell
					this.cells.deleteWall(randNdxs.get(j), this.h, -1, 0);
				}
			}
			
		}
	
	}
	
	/**
	 * Randomly determine vertical connections, with at least one per set. Called on a set by set basis
	 */
	private void verticalConnect(int setID){

		int maxNumConnects = getNumCellsSet(setID); //gives us the maximum number of connections
		
		//chooses a random number of connections, with bottom limit of 1
		int numConnects = rand.nextInt(maxNumConnects) + 1;
		
		int[] nextRow = new int[this.width];
		for(int i = 0; i < this.width; i ++){
			nextRow[i] = this.cells.getValueOfCell(h + 1, i);
		}
		
		
		//find upper and lower index bounds of set in row
		//iterate of curRow, find key(index) that equals setID, keep going until it no longer does, return upper and lower
		int lowBound = 0;
		int upBound = 0;
		for(int j = 0; j< width; j++){
			if(sets.get(curRow[j]) == setID){
				lowBound = j;
				while(sets.get(curRow[j]) == setID){
					j++;
				}
				upBound = j;
				break;
			}
		}
		
		//randomly chooses numConnects indices between lower and upper bounds
		int[] randomNdxs = new int[numConnects];
		for(int i = 0; i < numConnects; i++){
			randomNdxs[i] = rand.nextInt((upBound - lowBound) + 1) + lowBound;
		}
		
		//need to get cells that were randomly chosen between upper and lower bounds using randomNdxs and 
		//delete wall below it and join the cell to the set 
		for(int j = 0; j< randomNdxs.length; j++){
			
			//the randomly chosen cell within the boundary!!
			int refCell = curRow[randomNdxs[j]];
			int southCell = this.cells.getValueOfCell(j, (h - 1) ); //cell below refCell
			
			//we now check if they are part of the same set, if not, we add them to the same set
			if(! (this.areSameSet(refCell, southCell) )){
				int refCellSet = sets.get(refCell);
				sets.put(southCell, refCellSet);
				
				//delete wall below refCell-- randNdxs.get(j) is the index of the randomly chosen cell
				this.cells.deleteWall(randomNdxs[j], this.h, 0, -1);
				
			}
			else{
				System.out.println("the south cell and refCell are part of the same set, something is up");
			}
			
		}
		
		
	}
	
	
	
	/**
	 * gets the number of cells in a set
	 * @param set the set of interest
	 * @return number of cells in a given set
	 */
	private int getNumCellsSet(int set){
		
		int setOfCellVal;
		
		int setCount = 0;
		for(int i = 0; i < this.width; i++){
			setOfCellVal = sets.get(curRow[i]);
			if(setOfCellVal == set){
				setCount++;
			}
		}
		return setCount;
		
	}
	
	
	/**
	 * checks if two cells are part of the same set
	 * @param cell1
	 * @param cell2
	 * @return
	 */
	private boolean areSameSet(int cell1, int cell2){
		int val1 = sets.get(cell1); //the set that cell1 belongs too
		int val2 = sets.get(cell2); //the set that cell2 belongs too
		
		if(val1 == val2){
			return true;
		}
		return false;
	}
	
	/**
	 * Gets the number of sets in a row of cells. If the row is comprised only of 1 set, 1 is returned 
	 * @param row the row being inspected
	 * @return the number of sets in a row
	 */
	private int getNumSets(int[] row){
		int num = 1; 
		int refCell = row[0];
		for(int i = 0; i < row.length; i++){
			int otherCell = row[i];
			if(!(this.areSameSet(refCell, otherCell))){
				num++;
			}
		}
		return num;
	}
	
	/**
	 * generate a unique set number for each cell
	 * @param row A row of cells
	 */
	private void generateSets(int[] row){
		for(int i = 0; i < row.length; i++){
			int weightedSum = i*2 + this.h *3;
			int setNum = weightedSum;
			sets.put(row[i], setNum);
		}
	}
	
	/**
	 * gets specified number of random indices of a whole ROW
	 * @param num number of random indices to compute
	 * @return ArrayList of integers
	 */
	private ArrayList<Integer> getRandomIndices(int num){
		ArrayList<Integer> randNdxs = new ArrayList<Integer>();
		for(int i = 0; i < num; i++){
			int myRand = rand.nextInt(width); //what if it chooses an ndx thats already in there?
			//checks to see if an index is already in the array
			
			if(! randNdxs.contains(myRand) ){ //POSSIBLE ERROR
				randNdxs.add(myRand);
			}
		}
		return randNdxs;
	}
	
}

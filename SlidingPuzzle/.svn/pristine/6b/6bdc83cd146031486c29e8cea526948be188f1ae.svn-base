int[] puzzle = new int[4];int[] game = {		1, 2, 0, 3};puzzle = game;
for (int i = 0; i < puzzle.length; i++){	if (puzzle[i] == 0){		System.out.println("\n" + i);	}		}	double l = 4;int width = (int) Math.sqrt(l);System.out.println(width);System.out.println("Element at index 0: "
        + puzzle[0]);
System.out.println("Element at index 1: "
        + puzzle[1]);
System.out.println("Element at index 2: "
        + puzzle[2]);
System.out.println("Element at index 3: "
        + puzzle[3]);
System.out.print(puzzle.length);int i = 0;System.out.println(i);int x = 10;int y = 11;if (x < y) {	System.out.println();}int[] a = new int[10];System.out.print(a[8]);//Creates new instance of variable to be returnedSimplePuzzleState s1 = new SimplePuzzleState();s1.puzzle = this.getState();s1.parent = this.getParent();s1.prevOp = this.getOperation();int blankIndex = Arrays.asList(s1.getState()).indexOf(0); //blank values indexint otherValIndex = (Arrays.asList(s1.getState()).indexOf(0)) - 3; //index of value to be switched int otherVal = this.puzzle[otherValIndex]; //the actual value to be switched//THE switchs1.puzzle[otherValIndex] = 0; s1.puzzle[blankIndex] = otherVal;public int[] getPuzzle() {	return puzzle;}public void setPuzzle(int[] puzzle) {	this.puzzle = puzzle;}public Operation getPrevOp() {	return prevOp;}public void setPrevOp(Operation prevOp) {	this.prevOp = prevOp;}public int getDist() {	return Dist;}public void setDist(int dist) {	Dist = dist;}@Override/** Allows to configure the puzzle state to a particular game state.  * The state is provided as an array of integer. For instance, an  * one dimensional integer array {0,1,3,2} represents a state of 2x2  * puzzle with the first row carrying values 0 and 1, the second row  * carrying values 3 and 2. * @param gameState Provides a value for each tile in the current state of the game. */public void setState(int[] gameState) 	{	puzzle = gameState; 	}@Override/** Get the current puzzle state in a single dimensional array  * (i.e. {0,1,3,2} for 2x2 puzzle). Blank tile is represented as 0.  * The coding goes by rows, for the example the top row contains  * values 0 and 1 from left to right. This method is symmetric to  * setState and returns an array of same content that was assigned  * with the setState method. * @return the gamestate set in setState */public int[] getState() {		return puzzle;}@Override/**Get the parent state which was previously set with the setParentState *  method. The parent state is useful if one wants to represent that a  *  puzzle state A moves to puzzle state B with a particular move operation.  *  For this example B.getParentState() returns A. Obtaining A is useful  *  to extract a path from a starting state to a final state once the  *  final state is reached. *  @return Returns the parent of the current state. */public PuzzleState getParent() {		return parent;}@Override/** Sets the parent state. * @param parentState */public void setParent(PuzzleState parentState) {		parent = parentState;	}@Override/** Sets the operation to achieve this state * @param op The last operation */public void setOperation(Operation op) {		this.prevOp = op;}@Override/** Returns the operation last used to achieve this state * @return op - the last operation */public Operation getOperation() {		return this.prevOp;}@Override/** Set distance from initial state. The initial state  * has distance 0, states that are reached with one  * move have distance one and so forth * @param distance The distance from the initial state */public void setDistance(int distance) {		this.Dist = distance;}@Override/** Get distance from initial state * @returns distance from the intitial state */public int getDistance() {		return this.Dist;}int[] a = {0,1,2,3};int[] b = {3,2,1,0};PuzzleSolver ps = new BFSSolver();ps.configure(a, b);An exception occurred during evaluation:  java.lang.NullPointerExceptionAn exception occurred during evaluation:  java.lang.NullPointerExceptionPuzzleState pState= new SimplePuzzleState();int[] easyPuz = {1, 2, 0, 3};pState.setState(easyPuz);pState.moveUp();SimplePuzzleState s = new SimplePuzzleState();s.setFields(pState);s.state[0] = 0;s.getParent();s.setParent(pState);s.setFields(pState);
//MOVEUP methodSimplePuzzleState s = new SimplePuzzleState(); //THIS = pStates.setFields(pState);int blank = s.getZeroNdx(s.getState()); //gets the zero index 1d viewint width = s.getWidth(); //gets the puzzle width - just the square root of the sizeSystem.out.println("width: " + width);int row = s.getRowNdx(blank, width); //gets the row index of the zero 2d viewSystem.out.println("row: " + row);int col = s.getColNdx(blank, width); //gets the column index of the zero 2d viewint ogNdx = col + (width*(row - 1)); //index of the value above the zeroint switchVal = s.getState()[ogNdx]; //Value of the space above the zeros.getState()[ogNdx] = 0;s.getParent();s.getState()[blank] = switchVal;s.setDistance(pState.getDistance() + 1);int[] b = {1,2,3};b.equals(a);//stuff that may not workQueue<Object> toDo = new LinkedList<Object>();int max = this.getMaxSizeOfQueue();Vector<Object> known = new Vector<Object>();known.add(initState);toDo.add(initState);while( !toDo.isEmpty() ){		//Impossible case check	if( toDo.size() > max){		return null;	}	PuzzleState child = new SimplePuzzleState(); 		PuzzleState curState = (PuzzleState) toDo.remove(); //REMOVAL		if(curState.equals(goalState)){		Operation[] returnPath = new Operation[ curState.getDistance() ];		System.out.println("returnPath.length: " + returnPath.length);				if(returnPath.length > 0){			int lastNdx = returnPath.length - 1;						System.out.println("lastNdx: " + lastNdx);			returnPath[lastNdx] = curState.getOperation(); //last operation that was done, placed at the last ndx of the operation array			curState = curState.getParent();						while( curState.getOperation() != null){				lastNdx = lastNdx - 1; //				returnPath[lastNdx] = curState.getOperation();				curState = curState.getParent();			}			return returnPath;		}		else{			//initial was goal, so no moves are needed			return returnPath;		}					}		int[] board = curState.getState();		// gets list of all valid moves for node	Operation[] moves = this.validMoves(board);		int op = 0;	Operation operation = moves[op];	while(operation != null){				if(operation == Operation.MOVEUP){			child = curState.moveUp();		}		else if(operation == Operation.MOVEDOWN){			child = curState.moveDown();		}		else if(operation == Operation.MOVELEFT){			child = curState.moveLeft();					}		else if(operation == Operation.MOVERIGHT){			child = curState.moveRight();					}		if( ! (this.contains(known, child)) ){			known.addElement(child);			toDo.add(child);		}		op++;		operation = moves[op];	}}return null;}@Overridepublic Operation[] movesToSolve() {		HashMap<Integer, PuzzleState> k = new HashMap<Integer, PuzzleState>();	//Stack<PuzzleState> toDo = new Stack<PuzzleState>();	HashMap<Integer, PuzzleState> toDo = new HashMap<Integer, PuzzleState>();	//Vector<PuzzleState> known = new Vector<PuzzleState>(); //known states	int max = this.getMaxSizeOfQueue(); 	int key = 0;	//adds initial State to known puzzles and toDo queue	k.put(key, initState);	//known.addElement(initState);	//toDo.push(initState);	toDo.put(key, initState);while( !toDo.isEmpty() ){		//Impossible case check	if( toDo.size() > max){		return null;	}		PuzzleState child = new SimplePuzzleState(); 	//PuzzleState curState = (PuzzleState) toDo.remove(toDo.size() - 1); //removes last candidate from toDo list	//PuzzleState curState = (PuzzleState) toDo.pop();	PuzzleState curState = (PuzzleState) toDo.get(key);	toDo.remove(key, curState);		if(curState.equals(goalState)){		Operation[] returnPath = new Operation[ curState.getDistance() ];				if(returnPath.length > 0){			int lastNdx = returnPath.length - 1;						//last operation that was done, placed at the last ndx of the operation array			returnPath[lastNdx] = curState.getOperation(); 			curState = curState.getParent();						//Gets the array of operations			while( curState.getOperation() != null){				lastNdx = lastNdx - 1; //				returnPath[lastNdx] = curState.getOperation();				curState = curState.getParent();			}			return returnPath;		}		else{			//initial was goal, so no moves are needed			return returnPath;		}	}		int[] board = curState.getState();		// gets list of all valid moves for node	Operation[] moves = this.validMoves(board);		//generates successors of previous node	int op = 0;	for(op = 0; op < moves.length; op++){				Operation operation = moves[op];				if(operation == Operation.MOVEUP){			child = curState.moveUp();		}				else if(operation == Operation.MOVEDOWN){			child = curState.moveDown();							}				else if(operation == Operation.MOVELEFT){			child = curState.moveLeft();							}				else if(operation == Operation.MOVERIGHT){			child = curState.moveRight();						}				//if not part of known list, added		//if( (operation != null) && (!this.contains(known, child)) ){		//	known.addElement(child);		//	toDo.push(child);		//}		if((!this.knownCheck(k, child)) && (operation != null)){			key++;			k.put(key, child);			//toDo.push(child);			toDo.put(key, child);		}	}}return null;}